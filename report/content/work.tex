\section{Travaille réaliser}

\subsection{Défrichage / démarrage ?}

Pour prend en main \Eigen et \MIPP j'ai commancer par implementer un produit
vecteur matrice avec les deux bibliothèques.

Ensuite j'ai chercher ou ce trouvé les implémentations vectoriel explicite dans \Eigen
et comment elles sont implémentées.

Chaque architectures sont implémentées en 4 fichiers. Le premier \emph{PacketMath.h}
définit \hyperref[typeEigen]{les types} que \Eigen utilise pour représenté les
vecteurs et les implémentations des operations vectoriel pour chacun d'entre eux.
Il y a une implémentation générique de ce fichier pour les type scalaire. Le second
\emph{TypeCasting.h} définit les conversion entre les différant \hyperref[typeEigen]{types
vectoriel d'\Eigen}. C'est conversions concerne un peut toute les combinaison
de vecteurs de type entier, flottant, double, booléen, half\footnote{type present dans
\Eigen} et bfloat16\footnote{le type bfloat16 est décrit
\href{https://en.wikipedia.org/wiki/Bfloat16_floating-point_format}{ici}. Il y a une
implémentation présent dans \Eigen}. Le troisièmes \emph{MathFunctions.h}
implémente les operations mathématique non élémentaire comme : \texttt{ log, log2, log1p,
expm1, exp, sin, cos, sqrt, rsqrt, reciprocal, tanh, frexp, ldexp}. Le quatrième
\emph{Complex.h} définit \hyperref[typeEigen]{les types vectoriel d'\Eigen} et
les operations sur les nombre complex, simple et double precision.

\subsection{Les types représentent les vecteurs}
\Eigen et \MIPP représentent les vecteurs différemment voyons cela.

\label{typeEigen}
\subsubsection{La representation de vecteur dans Eigen}
{
  Les vecteurs sont de taille fix et représenté par des types. Ces représentation sont
  dépendent de l'architecture visé. Ces types sont nommés \emph{Packet} suivi d'un nombre.
  Ce nombre corresponde au nombre d'éléments que le vecteur peut contenir. Les type ce
  termine par une ou plusieurs letter qui corresponde au type des éléments du vecteur.
  Par example un vecteur qui contient quatre flottant sera nommé \emph{Packet4f} et
  correspondra au type AVX \emph{__m128} car un flottant et codé sur 32bits donc
  $32\cdot 4=128$. Il y as donc des représentation de différant tailles pour les entiers,
  les flottants (simple et double precision), les nombres complex\dots
  \Eigen et donc capable d'utilisé des taille de vecteur différente en même temps.
}

\subsubsection{La representation de vecteur dans MIPP}
{
  Les vecteurs sont de taille variable en fonction de l'architecture visé. \MIPP permet
  d'obtenir la taille des vecteurs qu'il manipule. Le \emph{code MIPP} dois respecté
  Le fait que les vecteurs on une taille variable. Il y a donc que 2 type de vecteurs
  \emph{reg} et \emph{reg2} qui fait la moitiés de la taille de \emph{reg}.
  \MIPP n'est donc pas capable d'utilisé différente taille de vecteur à la fois.
}

// dans `Eigen/src/Core/util/ConfigureVectorization.h` j'ai ajouter un cas __MIPP__

// j'ai ajouter une nouvelle architecture MIPP dans `Eigen/src/Core/arch/` et que j'ai
charger dans `Eigen/Core`

// J'ai copier le contenu des architecture SSE, AVX et AVX512 dans les même fichier.
C'est 3 architecture qui fonctionne ensemble (AVX depend de SSE, etc)

// J'ai listé les différant type Eigen définit pour chaque architecture aussi que les
operations supporter (tableau avec toute les fonctions)

\begin{table}[H]
  \centering
  \begin{tabular}[H]{|l|l|l|l|}
    \hline
    \textbf{SSE} & \textbf{AVX} & \textbf{AVX2} & \textbf{AVX512} \\
    \hline
    Packet4f     & Packet8f     & Packet4l      & Packet16f       \\
    \hline
    Packet2d     & Packet4d     &               & Packet8d        \\
    \hline
    Packet4i     & Packet8i     &               & Packet16i       \\
    \hline
    Packet16b    & Packet8h     &               & Packet16h       \\
    \hline
                 & Packet8bf    &               & Packet16bf      \\
    \hline
  \end{tabular}
  \caption{Les type vectoriel Eigen par architecture}
\end{table}

// J'ai lancer les tests Eigen sur mon architecture fraîchement copier de AVX.

// En lancent les tests Eigen j'ai remarquer qu'il sont très long à ce lancer et qu'il
ne fonctionne pas à tous les coup.

// Pour que je puis tester efficacement et rapidement j'ai implémenter des tests de non
regression. Pour exécuter ces tests j'ai copier les fonctions actuel dans un nouveaux
fichier et j'ai suffixés ces fonctions par \emph{_old}.

// J'ai implémenter les test de non regression pour la fonctionne \emph{pset1}, qui
rempli un vecteur avec la même valeur a chaque case, et j'ai fait l'implémentation en
MIPP. Pour finir j'ai lancer mes tests qui passé.

// J'ai implémenter les test de non regression pour toutes les operations présent dans
PacketMath.h. Ces test fonctionne pour les architectures SSE, AVX, AVX2 et quelque AVX512.

// Mes test de non régression son capable d'afficher le contenu des vecteur dans le cas
ou il y a une différence entre la nouvelle version et l'ancienne version de l'operation.
Il sont aussi capable d'afficher le contenu des vecteur en binaire et d'afficher sans
plantage quant une operations n'existe pas dans MIPP.

% liaison vecteurs

// J'ai commancer sur une mauvaise piste con convertissant les Packet Eigen en reg2
lors qu'il été petit. Ce qui fait que je devais faire la transformation, \emph{combinate()}
, entre reg et reg2 a chaque fois que je voulais faire un calcule car, dans MIPP, il
n'y a presque aucune operations sur les reg2. De plus cela ne fonctionné pas avec AVX512
et ajouter pleins de complication ce qui fait que j'ai du faire des conversion.

// Comme il MIPP ne peut pas utilisé des taille de vecteur différant je suis obliger de
cast les vecteur entre Eigen et MIPP\dots je me retrouve donc à faite des conversion
entre des vecteurs de taille différant par exemple un vecteur de 128 bits que je dois
convertir en vecteur de 512 bits et inversement. Ces conversion peuvent amené a une
perte de performance. (Benchmark here ?)

// Dans un premier temps, pour chaque fonction, j'ai fait l'implémentation en MIPP pour
chaque type quelle support. Ce qui ma amené à avoir 2 fois la même implémentation MIPP
avec seulement le type qui change par exemple une \emph{pset1<Packet4f>()} et une autre
\emph{pset1<Packet4i>}. Dans un second temps le but à été de \textit{replier} les
fonctions pour en avoir qu'une seul. Mais je suis tombés sur un problème, le
comportement par défaut et une operation scalaire. En effet Eigen permet d'activer
ou non la vectorisation. Lors que la vectorisation et désactiver se sont les même
operations qui sont appelé mais, dans ce cas, c'est l'operation par défaut qui est
appelé et quant la vectorisation et activer on tombe sur un cas spécifique (Le Packet)
et preciser a l'appelle. On ce retrouve donc avec 2 cas spécifique, un pour les scalaire
et un pour les vecteurs. Cette situation amené à un état compliqué qui reste encore à
résoudre. Peut-être 2 solutions :

// * Tous coder et faire en sorte que tous les Packet corresponde au type reg de MIPP,
ce qui permet d'avoir un seul type.

// * Ajouter des adaptateur pour avoir une arborescence et utiliser le polymorphisme.

// Grace à mes tests et mes quelque implémentation j'ai pu lister des operations qu'il
manque dans MIPP :

\begin{table}[H]
  \centering
  \caption*{\texttimes: absent de MIPP \checkmark: present dans MIPP}
  \begin{tabular}[H]{|m{.238\linewidth}|m{.1205\linewidth}|m{.0872\linewidth}|m{.0705\linewidth}|m{.1594\linewidth}|m{.108\linewidth}|}
    \hline
                     & \textbf{AVX512} & \textbf{AVX2} & \textbf{AVX} & \textbf{SSE4.1/4.2} & \textbf{SSE2/3} \\
    \hline
    add<int32_t>    & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \checkmark      \\
    \hline
    sub<int32_t>    & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \checkmark      \\
    \hline
    mul<int32_t>    & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \texttimes      \\
    \hline
    orb<int8_t>     & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \checkmark      \\
    \hline
    xor<int8_t>     & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \checkmark      \\
    \hline
    and<int8_t>     & \checkmark      & \checkmark    & \texttimes   & \checkmark          & \checkmark      \\
    \hline
    cmpneq<int16_t> & \texttimes      & \checkmark    & \texttimes   & \texttimes          & \texttimes      \\
    \hline
    cmpneq<int8_t>  & \texttimes      & \checkmark    & \texttimes   & \texttimes          & \texttimes      \\
    \hline
  \end{tabular}
  \caption{Abstractions MIPP non implementer}
\end{table}

// Pour exécuter le code en AVX512 j'ai utilisé PlaFRIM\dots
